##### 抄自知乎

1. 作者：张天行
链接：https://www.zhihu.com/question/30395946/answer/119404424
来源：知乎

数字是用来记录现实世界数量属性的语言。

而任何计数系统都必须有两个参数：容量和精度。

模是衡量计数系统容量的参数。模代表了计数系统所能表示和存储的状态数。

任何有限的计数系统都有一个确定的模。如时钟的模是12（即只有一个位的十二进制系统，要是再加一个大钟，使小钟转一周大钟加一刻度，就是有两个位的十二进制系统），再比如8位计算机的模是2^8=256D=2*10^8B（每一位也可以单独看做一个模为2的计数系统）。

对同一计数系统中的数量可以定义运算如相加，但运算结果超出预设位数时，就要发生溢出，这个溢出其实就是模，如果进位没有被另一个计数系统接受，结果看似“失真”，本质上是进入了“第二次循环”。
以时钟系统为例：8+7=15D=13（十二进制）>10（十二进制），进位1溢出丢失（除非用另一个时钟记录），在表盘上（即时钟计数系统中）呈现为3，而8-5=8+(-5)=3也得到了相同结果。

因此我们在有限的计数系统中可以定义一个概念“补数”。正数补数即为本身，负数A【补】=模-绝对值（A）。上例-5对12的补数就是10-5=7（注意这是十二进制里的运算）。一个数加上另一个数（可以是正数也可以是负数），结果等于加上这个数的补数，若有进位则舍弃进位。这里的舍弃进位，一点也不唐突，舍弃的，就是系统的模，也就是时钟的一整圈！这本质上，是因为所有有限模的计数系统都可以看做一个“环”或者“钟”，下面再对计算机的8位运算进行说明。

在8位计算机中，可以表示256种状态，刻度其实是随便标的，不如取0点钟为-128，正对的6点钟为0，即存储范围是从-128到127（用二进制补码表示是10000000~01111111，10000000用来表示-128很特殊，这个数按规则本来似乎应是-0）。
计算机中，所有数字都以补码形式存储和运算（对计算机来说根本没有什么原码反码，原码只是更直观方便人理解，反码就是个过渡，建议大家不要再去想原码和反码了，只会添乱），真正定义的运算只有一种“加法”，硬件上通过全加器这种基本电路实现，其他运算如减乘除本质都是加法。正数的补码就是符号位0加上它的二进制数，负数的补码就是符号位1加上它的二进制数取反再加1。今后，计算机做的事就是拿这些补码加加加，符号位也参与运算，得到的结果也是补码，存储进存储器的也是补码，多方便。

举个例子，7-9=？，7的补码是00000111，-9的补码是11110111，7+（-9）=11111110，对结果求补得原码10000010就是-2。

那么求负数补码的规则又是怎么来的呢？还记得前面提到的负数A【补】=模-绝对值（A）吗？拿-126举例，绝对值是01111110，模是100000000，模减去绝对值即为10000010就是-126的补码，而100000000-01111110=（11111111+1）-01111110=（11111111-01111110）+1，仔细一看，（11111111-01111110）的结果10000001不就是126按位取反么？甚至符号位都不需要人为定义，这个首位的1就自然地由取反得到了！最后再加1和书本上的方法也正好吻合！现在回顾一下教科书上的说法：给正数一个符号位0，给负数一个符号位1，取反的时候还要保持符号位不动，翻转后面的数，难道不是多此一举？这样的方法只不过是给不理解补数的人用来死记硬背求补的流程罢了。“符号位”原来不应该是人为了区分正负而生硬规定的，是原本求补过程就存在的一个普通的位置，只是它恰好能够指明数的正负，使人一眼能看出符号，所以才被加了“符号位”这个名字。

补数本天成，妙手偶得之！

最后再回答一个经常问的问题：“-128的补码为什么是10000000？难道是把-0的位置让给了-128？”，在我看来，这就是一个被教材硬造出的“符号位”概念误导导致无法理解的事情。套用求补的公式：100000000-10000000=10000000，就得到了，-128的绝对值就是10000000啊，有的人就非得把首位的1变成0，就无法可想了。

最后的最后，再聊一聊“负数加负数会变成正数，正数加正数会变成负数”。显然，计数系统是无法表示超出其取值范围的计算结果的。
举两个例子：120D+120D=01111000B+01111000B=11110000B再求补得10010000B也就是-16D，放在钟面上就是从120顺时针旋转120到240的位置，只不过系统最大只取到127，240的位置就是-16的位置，而且-16和240不正好是关于模256的一对补数么。相似的，-120D-120D=16D也有相同解答。在有限的计数系统内，由于位数的限制，发生溢出的情况下无法得到计算真实值，得到的是真实值关于模的补数！


所以模256下的加减法，用0, 1, 2, …, 254,255表示其值，或者用−128, −127,… , −1, 0, 1, 2,… ,127是完全等价的。−128与128，−127与129，…，−2与254，−1与255可以互换而加减法的结果不变。从而，把8位元（octet） 的高半部分(即二进制的1000 0000到1111 1111)解释为−128到−1，同样也实现了模256的加减法，而且所需要的CPU加法运算器的电路实现与8位元无符号整数并无不同。
实际上对于8比特的存储单元，把它的取值[00000000, …, 11111111]解释为[0, 255], 或者[-1, 254], 或者[-2, 253], 或者[-128, 127], 或者[-200, 55], 甚至或者[500, 755], 对于加法硬件实现并无不同。
作者：iittttt
链接：https://www.zhihu.com/question/30395946/answer/55125597
来源：知乎

